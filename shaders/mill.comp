#version 460 core

layout(local_size_x = 32, local_size_y = 32) in;

// --- Inputs ---
layout(r32f, binding = 0) uniform image2D heightMap;  // Writable heightmap (float)
layout(binding = 1) uniform atomic_uint resultBits;

uniform vec3 blockSize;    // (m_sizeX, unused, m_sizeZ)
uniform ivec2 resolution;  // (m_resX, m_resZ)
uniform bool ballBlade;
uniform vec3 bladePos; 
uniform float bladeRadius;
uniform float bladeHeight;
uniform float baseHeight;
uniform ivec2 leftBottomPixel;
uniform ivec2 pixels;

float getMillingHeight(float dist2, float radius)
{
    if (dist2 >= radius * radius)
        return 1e9;
    if(ballBlade){
      float dy = sqrt(radius * radius - dist2);
      return bladePos.y + radius - dy;
    }
    return bladePos.y;
}

void main()
{
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    if (id.x >= pixels.x || id.y >= pixels.y)
        return;

    ivec2 texCoord = leftBottomPixel + id;
    
    if (texCoord.x < 0 || texCoord.x >= resolution.x || 
        texCoord.y < 0 || texCoord.y >= resolution.y)
        return;

    float stepX = blockSize.x / float(resolution.x);
    float stepZ = blockSize.z / float(resolution.y);

    float worldX = float(texCoord.x) * stepX;
    float worldZ = float(texCoord.y) * stepZ;

    float dx = worldX - bladePos.x;
    float dz = worldZ - bladePos.z;
    float dist2 = dx * dx + dz * dz;

    if (dist2 <= bladeRadius * bladeRadius)
    {
        float newHeight = getMillingHeight(dist2, bladeRadius);

        // Read current height
        float oldHeight = imageLoad(heightMap, texCoord).r;

        // Remove material (never add)
        if (newHeight < oldHeight)
        {
            imageStore(heightMap, texCoord, vec4(newHeight, 0.0, 0.0, 0.0));
            atomicCounterOr(resultBits, 1u << 0);

            if(oldHeight - bladePos.y > bladeHeight){
              atomicCounterOr(resultBits, 1u << 1);
            }
            if(newHeight < baseHeight){
              atomicCounterOr(resultBits, 1u << 2);
            }
        }
    }
}

