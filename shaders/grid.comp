#version 460 core

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, r32f) uniform readonly image2D heightMap;

struct Vertex {
    vec4 pos;
    vec4 norm;
    vec2 tex;
};

layout(std430, binding = 0) buffer Vertices {
    Vertex v[];
};


uniform uint gridWidth;
uniform uint gridHeight;
uniform vec2 size;       // physical size of grid (e.g. 1x1 or 100x100)

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x >= gridWidth || y >= gridHeight) return;
    uint offset = (gridHeight + gridWidth) * 2;
    uint index = offset + (x * gridHeight) + y;

    vec2 uv = vec2(float(x) / float(gridWidth - 1),
                   float(y) / float(gridHeight - 1));


    // Sample height
    float h = imageLoad(heightMap, ivec2(x, y)).r;
    // Compute position in world space
    vec2 posXZ = uv * size;
    vec3 pos = vec3(posXZ.x, h, posXZ.y);

    // Approximate normal from neighboring samples
    float hL = imageLoad(heightMap, ivec2(max(int(x)-1,0), y)).r;
    float hR = imageLoad(heightMap, ivec2(min(int(x)+1,int(gridWidth-1)), y)).r;
    float hD = imageLoad(heightMap, ivec2(x, max(int(y)-1,0))).r;
    float hU = imageLoad(heightMap, ivec2(x, min(int(y)+1,int(gridHeight-1)))).r;

    vec3 dx = vec3(2.0 * size.x / float(gridWidth-1), hR - hL, 0.0);
    vec3 dz = vec3(0.0, hU - hD, 2.0 * size.y / float(gridHeight-1));
    vec3 normal = normalize(cross(dz, dx));

    v[index].pos = vec4(pos / 10.f, 1.f);
    v[index].norm = vec4(normal, 0.f);
    v[index].tex = uv;
}

